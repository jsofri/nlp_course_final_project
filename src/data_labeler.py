import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from utils import Experiment, DEFAULT_AUTOGENERATED_EXPERIMENT_FILE, DEFAULT_LABELED_FILE
import argparse
import json


class DataLabeler:
    def __init__(self, label: "Label"):
        self.labels = label
        self.current_prediction = []

        self.root = tk.Tk()
        self.root.tk.call('tk', 'scaling', 2.0)
        self.set_window()

        self.label_frame = tk.Frame(self.root)
        self.label_frame.pack()

        self.set_keys()

        self.word_label = ctk.CTkLabel(self.label_frame, text="Word:", text_color="black")
        self.word_label.grid(row=0, column=0)

        self.word_var = tk.StringVar()
        self.word_entry = ctk.CTkEntry(self.label_frame, textvariable=self.word_var, state='disabled')
        self.word_entry.grid(row=0, column=1)

        self.prediction_label = ctk.CTkLabel(self.label_frame, text="Syllables:", text_color="black")
        self.prediction_label.grid(row=1, column=0)

        self.prediction_var = tk.StringVar()
        self.prediction_entry = ctk.CTkEntry(self.label_frame, textvariable=self.prediction_var, state='disabled')
        self.prediction_entry.grid(row=1, column=1)

        self.label_var = tk.StringVar()
        self.label_var.set("TP")

        self.TP_radio = ctk.CTkRadioButton(self.label_frame, text="TP (1)",
                                           variable=self.label_var, value="TP", text_color="black")
        self.TP_radio.grid(row=2, column=0)

        self.FP_radio = ctk.CTkRadioButton(self.label_frame, text="FP (2)",
                                           variable=self.label_var, value="FP", text_color="black")
        self.FP_radio.grid(row=2, column=1)

        self.FN_radio = ctk.CTkRadioButton(self.label_frame, text="FN (3)",
                                           variable=self.label_var, value="FN", text_color="black")
        self.FN_radio.grid(row=2, column=2)

        self.pass_radio = ctk.CTkRadioButton(self.label_frame, text="Pass (Enter)",
                                             variable=self.label_var, value="Pass", text_color="black")
        self.pass_radio.grid(row=2, column=3)

        self.next_button = ctk.CTkButton(self.root, text="Next", command=self.next_word)
        self.next_button.pack()

        self.counter = ctk.CTkLabel(self.label_frame, text="", text_color="black")
        self.counter.grid(row=3, column=1)

        self.update_display()

    def launch(self):
        self.root.mainloop()

    def set_keys(self):
        self.root.bind('1', self.key_handler)
        self.root.bind('2', self.key_handler)
        self.root.bind('3', self.key_handler)
        self.root.bind('<Return>', self.key_handler)

    def set_window(self):
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()

        x = (screen_width - 400) // 2
        y = (screen_height - 300) // 2

        self.root.geometry(f"500x150+{x}+{y}")
        self.root.title("Data Labeling Tool")

    def update_display(self):
        if len(self.current_prediction) > 0:
            self.pass_radio.configure(state='disabled')
            pred_str = '-'.join(self.labels.data[self.labels.index][1])
            self.prediction_var.set(self.current_prediction[0] + f'   [{pred_str}]')
            self.current_prediction = self.current_prediction[1:]

        elif self.labels.index < len(self.labels.data):
            self.labels.add()
            self.pass_radio.configure(state='normal')
            word, self.current_prediction = self.labels.data[self.labels.index]

            self.word_var.set(word)

            pred_str = '-'.join(self.current_prediction)
            self.prediction_var.set(self.current_prediction[0] + f'   [{pred_str}]')
            self.counter.configure(text=f"{self.labels.index}/{len(self.labels.data)}")

            self.current_prediction = self.current_prediction[1:]
        else:
            messagebox.showinfo("Labeling Completed", "All data labeled.")
            self.root.quit()

    def next_word(self):
        label = self.label_var.get()
        self.labels.add_to_last(label)

        if label == 'Pass':
            self.current_prediction = []

        self.next_data()

    def next_data(self):
        if len(self.current_prediction) == 0:
            self.labels.index += 1
        if self.labels.index < len(self.labels.data):
            self.update_display()
        else:
            messagebox.showinfo("Labeling Completed", "All data labeled.")
            self.root.quit()

    def key_handler(self, event):
        match event.keysym:
            case '1': self.labels.add_to_last("TP")
            case '2': self.labels.add_to_last("FP")
            case '3': self.labels.add_to_last("FN")
            case 'Return':
                if self.pass_radio._state == 'disabled':
                    return
                self.labels.add_to_last("Pass")
                self.current_prediction = []

        self.next_data()


class Label:
    def __init__(self):
        self.model = ''
        self.data = []
        self.labels = []
        self.index = 0

    @classmethod
    def generate_cls(cls, experiment: Experiment = None,
                     model: str = '', data: list = None, labels: list = None, index: int = 0) -> "Label":
        obj = cls()

        if experiment:
            obj.model = experiment.model_name
            obj.data = obj.extract_data(experiment)
        else:
            obj.model = model
            obj.data = data
            obj.labels = labels
            obj.index = index

        return obj

    def add_to_last(self, label):
        self.labels[-1].append(label)

    def add(self):
        self.labels.append([])

    @staticmethod
    def extract_data(experiment: Experiment) -> list:
        return [(instruction.word.word, instruction.response['syllables'].split('-'))
                for instruction in experiment.instructions]

    @staticmethod
    def to_json(label: "Label") -> dict:
        return {
            "model": label.model,
            "labels": [{"word": label.data[i][0],
                        "response": [r for r in label.data[i][1]],
                        "label": [lab for lab in label.labels[i]]}
                       for i in range(label.index)]
        }

    @staticmethod
    def from_json(data: dict) -> "Label":
        return Label.generate_cls(None,
                                  data['model'],
                                  [(entry['word'], entry['response']) for entry in data["labels"]],
                                  [[lab for lab in entry['label']] for entry in data["labels"]],
                                  len(data["labels"]))


def run(experiment_file: str, output_file: str):
    try:
        with open(experiment_file, 'r') as f:
            data = json.load(f)
        experiment = Experiment.from_json(data)
    except Exception as e:
        print("Error loading inputs:", e)
        exit(1)

    labels: Label = Label.generate_cls(experiment)

    labeler: DataLabeler = DataLabeler(labels)
    labeler.launch()

    with open(output_file, 'w') as f:
        json.dump(labels.to_json(labels), f, indent=4)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Label the data")
    parser.add_argument("--experiment", type=str, default=DEFAULT_AUTOGENERATED_EXPERIMENT_FILE,
                        help="Experiment file name")
    parser.add_argument("--output_file", type=str, default=DEFAULT_LABELED_FILE,
                        help="Output file name")

    args = parser.parse_args()
    run(args.experiment, args.output_file)
